/**
 * Modules in this bundle
 * @license
 *
 * dicom-parser:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Chris Hafey <chafey@gmail.com> (https://github.com/chafey)
 *   homepage: https://github.com/OHIF/dicom-parser
 *   version: 2.0.2
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.dicomParser = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _version = require('./version');

var _version2 = _interopRequireDefault(_version);

var _parsers = require('./lib/parsers');

var parsers = _interopRequireWildcard(_parsers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class
 */
var dicomParser = function () {
  function dicomParser() {
    _classCallCheck(this, dicomParser);
  }

  _createClass(dicomParser, null, [{
    key: 'version',


    /**
     * Current version of the library
     */
    get: function get() {
      return _version2.default;
    }
  }]);

  return dicomParser;
}();

// Parsers


dicomParser.parseDA = parsers.parseDA;
dicomParser.parseDicom = parsers.parseDicom;

exports.default = dicomParser;

},{"./lib/parsers":4,"./version":5}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Algorithm based on http://stackoverflow.com/questions/1433030/
var daysInMonth = function daysInMonth(m, y) {
  // Note: m is 0 indexed: 0-11
  switch (m) {
    case 2:
      return y % 4 === 0 && y % 100 || y % 400 === 0 ? 29 : 28;
    case 9:case 4:case 6:case 11:
      return 30;
    default:
      return 31;
  }
};

var isValidDate = function isValidDate(d, m, y) {
  // Make year is a number
  if (isNaN(y)) {
    return false;
  }

  return m > 0 && m <= 12 && d > 0 && d <= daysInMonth(m, y);
};

/**
 * Parses a DA formatted string into a Javascript object
 * @memberof dicomParser
 * @param {string} date A string in the DA VR format
 * @param {boolean} [validate] - Throws exception if the date is invalid?
 * @returns {object} Object with properties year, month and day will return
 * undefined if not present or not 8 bytes long
 */
var parseDA = function parseDA(date, validate) {
  if (date && date.length === 8) {
    var yyyy = parseInt(date.substring(0, 4), 10);
    var mm = parseInt(date.substring(4, 6), 10);
    var dd = parseInt(date.substring(6, 8), 10);

    if (validate && isValidDate(dd, mm, yyyy) !== true) {
      throw new Error("invalid DA \"" + date + "\"");
    }

    return {
      year: yyyy,
      month: mm,
      day: dd
    };
  }

  if (validate) {
    throw new Error("invalid DA \"" + date + "\"");
  }

  return undefined;
};

exports.parseDA = parseDA;

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Parses a DICOM object
 * @memberof dicomParser
 * @todo Implement
 * @returns {object} Null
 */
var parseDicom = function parseDicom() {
  return null;
};

exports.parseDicom = parseDicom;

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _da = require('./da');

Object.defineProperty(exports, 'parseDA', {
  enumerable: true,
  get: function get() {
    return _da.parseDA;
  }
});

var _dicom = require('./dicom');

Object.defineProperty(exports, 'parseDicom', {
  enumerable: true,
  get: function get() {
    return _dicom.parseDicom;
  }
});

},{"./da":2,"./dicom":3}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = '2.0.2';

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmNcXGRpY29tLXBhcnNlci5qcyIsInNyY1xcbGliXFxwYXJzZXJzXFxkYS5qcyIsInNyY1xcbGliXFxwYXJzZXJzXFxkaWNvbS5qcyIsInNyY1xcbGliXFxwYXJzZXJzXFxpbmRleC5qcyIsInNyY1xcdmVyc2lvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0FDQUE7Ozs7QUFDQTs7SUFBWTs7Ozs7Ozs7QUFFWjs7O0lBR007Ozs7Ozs7OztBQUVKOzs7d0JBR3NCO0FBQ3BCO0FBQ0Q7Ozs7OztBQUlIOzs7QUFDQSxZQUFZLE9BQVosR0FBc0IsUUFBUSxPQUE5QjtBQUNBLFlBQVksVUFBWixHQUF5QixRQUFRLFVBQWpDOztrQkFFZTs7Ozs7Ozs7QUNyQmY7QUFDQSxJQUFNLGNBQWMsU0FBZCxXQUFjLENBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDbEM7QUFDQSxVQUFRLENBQVI7QUFDQSxTQUFLLENBQUw7QUFDRSxhQUFRLElBQUksQ0FBSixLQUFVLENBQVYsSUFBZSxJQUFJLEdBQXBCLElBQTRCLElBQUksR0FBSixLQUFZLENBQXhDLEdBQTRDLEVBQTVDLEdBQWlELEVBQXhEO0FBQ0YsU0FBSyxDQUFMLENBQVMsS0FBSyxDQUFMLENBQVMsS0FBSyxDQUFMLENBQVMsS0FBSyxFQUFMO0FBQ3pCLGFBQU8sRUFBUDtBQUNGO0FBQ0UsYUFBTyxFQUFQO0FBTkY7QUFRRCxDQVZEOztBQVlBLElBQU0sY0FBYyxTQUFkLFdBQWMsQ0FBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQjtBQUNyQztBQUNBLE1BQUksTUFBTSxDQUFOLENBQUosRUFBYztBQUNaLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU8sSUFBSSxDQUFKLElBQVMsS0FBSyxFQUFkLElBQW9CLElBQUksQ0FBeEIsSUFBNkIsS0FBSyxZQUFZLENBQVosRUFBZSxDQUFmLENBQXpDO0FBQ0QsQ0FQRDs7QUFTQTs7Ozs7Ozs7QUFRQSxJQUFNLFVBQVUsU0FBVixPQUFVLENBQVUsSUFBVixFQUFnQixRQUFoQixFQUEwQjtBQUN4QyxNQUFJLFFBQVEsS0FBSyxNQUFMLEtBQWdCLENBQTVCLEVBQStCO0FBQzdCLFFBQU0sT0FBTyxTQUFTLEtBQUssU0FBTCxDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBVCxFQUErQixFQUEvQixDQUFiO0FBQ0EsUUFBTSxLQUFLLFNBQVMsS0FBSyxTQUFMLENBQWUsQ0FBZixFQUFrQixDQUFsQixDQUFULEVBQStCLEVBQS9CLENBQVg7QUFDQSxRQUFNLEtBQUssU0FBUyxLQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLENBQWxCLENBQVQsRUFBK0IsRUFBL0IsQ0FBWDs7QUFFQSxRQUFJLFlBQVksWUFBWSxFQUFaLEVBQWdCLEVBQWhCLEVBQW9CLElBQXBCLE1BQThCLElBQTlDLEVBQW9EO0FBQ2xELFlBQU0sSUFBSSxLQUFKLG1CQUF5QixJQUF6QixRQUFOO0FBQ0Q7O0FBRUQsV0FBTztBQUNMLFlBQU0sSUFERDtBQUVMLGFBQU8sRUFGRjtBQUdMLFdBQUs7QUFIQSxLQUFQO0FBS0Q7O0FBRUQsTUFBSSxRQUFKLEVBQWM7QUFDWixVQUFNLElBQUksS0FBSixtQkFBeUIsSUFBekIsUUFBTjtBQUNEOztBQUVELFNBQU8sU0FBUDtBQUNELENBdEJEOztRQXdCUyxVQUFBOzs7Ozs7OztBQ3REVDs7Ozs7O0FBTUEsSUFBTSxhQUFhLFNBQWIsVUFBYSxHQUFZO0FBQzdCLFNBQU8sSUFBUDtBQUNELENBRkQ7O1FBSVMsYUFBQTs7Ozs7Ozs7Ozs7Ozs7ZUNWQTs7Ozs7Ozs7O2tCQUNBOzs7Ozs7Ozs7O2tCQ0RNIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCB2ZXJzaW9uIGZyb20gJy4vdmVyc2lvbic7XG5pbXBvcnQgKiBhcyBwYXJzZXJzIGZyb20gJy4vbGliL3BhcnNlcnMnO1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBkaWNvbVBhcnNlciB7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeVxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uICgpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbiAgfVxuXG59XG5cbi8vIFBhcnNlcnNcbmRpY29tUGFyc2VyLnBhcnNlREEgPSBwYXJzZXJzLnBhcnNlREE7XG5kaWNvbVBhcnNlci5wYXJzZURpY29tID0gcGFyc2Vycy5wYXJzZURpY29tO1xuXG5leHBvcnQgZGVmYXVsdCBkaWNvbVBhcnNlcjtcbiIsIi8vIEFsZ29yaXRobSBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0MzMwMzAvXG5jb25zdCBkYXlzSW5Nb250aCA9IGZ1bmN0aW9uIChtLCB5KSB7XG4gIC8vIE5vdGU6IG0gaXMgMCBpbmRleGVkOiAwLTExXG4gIHN3aXRjaCAobSkge1xuICBjYXNlIDI6XG4gICAgcmV0dXJuICh5ICUgNCA9PT0gMCAmJiB5ICUgMTAwKSB8fCB5ICUgNDAwID09PSAwID8gMjkgOiAyODtcbiAgY2FzZSA5IDogY2FzZSA0IDogY2FzZSA2IDogY2FzZSAxMSA6XG4gICAgcmV0dXJuIDMwO1xuICBkZWZhdWx0IDpcbiAgICByZXR1cm4gMzE7XG4gIH1cbn07XG5cbmNvbnN0IGlzVmFsaWREYXRlID0gZnVuY3Rpb24gKGQsIG0sIHkpIHtcbiAgLy8gTWFrZSB5ZWFyIGlzIGEgbnVtYmVyXG4gIGlmIChpc05hTih5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBtID4gMCAmJiBtIDw9IDEyICYmIGQgPiAwICYmIGQgPD0gZGF5c0luTW9udGgobSwgeSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIERBIGZvcm1hdHRlZCBzdHJpbmcgaW50byBhIEphdmFzY3JpcHQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgZGljb21QYXJzZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlIEEgc3RyaW5nIGluIHRoZSBEQSBWUiBmb3JtYXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbGlkYXRlXSAtIFRocm93cyBleGNlcHRpb24gaWYgdGhlIGRhdGUgaXMgaW52YWxpZD9cbiAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoIHByb3BlcnRpZXMgeWVhciwgbW9udGggYW5kIGRheSB3aWxsIHJldHVyblxuICogdW5kZWZpbmVkIGlmIG5vdCBwcmVzZW50IG9yIG5vdCA4IGJ5dGVzIGxvbmdcbiAqL1xuY29uc3QgcGFyc2VEQSA9IGZ1bmN0aW9uIChkYXRlLCB2YWxpZGF0ZSkge1xuICBpZiAoZGF0ZSAmJiBkYXRlLmxlbmd0aCA9PT0gOCkge1xuICAgIGNvbnN0IHl5eXkgPSBwYXJzZUludChkYXRlLnN1YnN0cmluZygwLCA0KSwgMTApO1xuICAgIGNvbnN0IG1tID0gcGFyc2VJbnQoZGF0ZS5zdWJzdHJpbmcoNCwgNiksIDEwKTtcbiAgICBjb25zdCBkZCA9IHBhcnNlSW50KGRhdGUuc3Vic3RyaW5nKDYsIDgpLCAxMCk7XG5cbiAgICBpZiAodmFsaWRhdGUgJiYgaXNWYWxpZERhdGUoZGQsIG1tLCB5eXl5KSAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIERBIFwiJHtkYXRlfVwiYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHl5eXksXG4gICAgICBtb250aDogbW0sXG4gICAgICBkYXk6IGRkXG4gICAgfTtcbiAgfVxuXG4gIGlmICh2YWxpZGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBEQSBcIiR7ZGF0ZX1cImApO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB7IHBhcnNlREEgfTtcbiIsIi8qKlxuICogUGFyc2VzIGEgRElDT00gb2JqZWN0XG4gKiBAbWVtYmVyb2YgZGljb21QYXJzZXJcbiAqIEB0b2RvIEltcGxlbWVudFxuICogQHJldHVybnMge29iamVjdH0gTnVsbFxuICovXG5jb25zdCBwYXJzZURpY29tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCB7IHBhcnNlRGljb20gfTtcbiIsImV4cG9ydCB7IHBhcnNlREEgfSBmcm9tICcuL2RhJztcbmV4cG9ydCB7IHBhcnNlRGljb20gfSBmcm9tICcuL2RpY29tJztcbiIsImV4cG9ydCBkZWZhdWx0ICcyLjAuMic7XG4iXX0=
